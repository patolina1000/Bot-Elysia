<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Admin Wizard - Multi-Bot Telegram</title>
  <style>
    :root {
      color-scheme: light dark;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 24px;
      color: #111827;
      display: flex;
      justify-content: center;
    }

    .layout {
      width: 100%;
      max-width: 960px;
      background: #ffffff;
      border-radius: 16px;
      box-shadow: 0 25px 70px rgba(17, 24, 39, 0.35);
      padding: 28px 28px 40px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    header.top {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    header.top h1 {
      font-size: 32px;
      margin: 0 0 4px;
    }

    header.top p {
      margin: 0;
      color: #4b5563;
      font-size: 15px;
    }

    .token-card {
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .token-card label {
      font-weight: 600;
      color: #1f2937;
      font-size: 14px;
    }

    .token-input {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .token-input input {
      flex: 1 1 220px;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #cbd5f5;
      font-size: 14px;
    }

    button,
    select,
    textarea,
    input {
      font-family: inherit;
    }

    .mono {
      font-family: 'SFMono-Regular', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    }

    button {
      border: none;
      border-radius: 8px;
      background: #6366f1;
      color: #ffffff;
      font-weight: 600;
      padding: 10px 16px;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    button:hover {
      background: #4f46e5;
    }

    button:disabled {
      background: #c7c9d6;
      cursor: not-allowed;
    }

    main.card {
      background: #ffffff;
      border-radius: 12px;
      border: 1px solid #e5e7eb;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
    }

    .card-header h2 {
      margin: 0;
      font-size: 22px;
      color: #111827;
    }

    .card-header p {
      margin: 4px 0 0;
      color: #6b7280;
      font-size: 14px;
    }

    #tabs {
      display: flex;
      align-items: center;
      gap: 8px;
      border-bottom: 1px solid #e5e7eb;
    }

    #tabs-scroll {
      display: flex;
      overflow-x: auto;
      gap: 6px;
      padding: 6px 0;
      flex: 1 1 auto;
    }

    #tabs-scroll::-webkit-scrollbar {
      height: 6px;
    }

    #tabs-scroll::-webkit-scrollbar-thumb {
      background: rgba(79, 70, 229, 0.35);
      border-radius: 999px;
    }

    .tab {
      padding: 8px 12px;
      border-radius: 10px;
      background: #f3f4f6;
      cursor: pointer;
      white-space: nowrap;
      user-select: none;
      font-size: 14px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .tab.active {
      background: #111827;
      color: #ffffff;
    }

    .tab .dirty {
      margin-left: 6px;
      color: #f59e0b;
      font-weight: 700;
    }

    #bot-actions {
      display: flex;
      gap: 8px;
      margin-left: auto;
    }

    #bot-actions button {
      padding: 8px 12px;
      border-radius: 8px;
      background: #e5e7eb;
      color: #111827;
      font-size: 16px;
    }

    #bot-actions button:first-child {
      background: #6366f1;
      color: #ffffff;
    }

    #bot-actions button:first-child:hover {
      background: #4f46e5;
    }

    #bot-actions button:hover {
      background: #d1d5db;
    }

    #pane {
      padding-top: 12px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    .hidden {
      display: none !important;
    }

    #no-bots {
      border: 1px dashed #cbd5f5;
      border-radius: 12px;
      padding: 20px;
      color: #4b5563;
      background: #f8fafc;
      text-align: center;
      font-size: 14px;
    }

    #bot-header {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      background: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      padding: 16px;
      font-size: 14px;
      color: #1f2937;
    }

    #bot-header > div {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    #bot-header code,
    #bot-header input {
      background: #11182710;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #cbd5f5;
      font-family: 'SFMono-Regular', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
      font-size: 13px;
      color: #111827;
    }

    #bot-header input {
      flex: 1 1 auto;
      min-width: 140px;
      border: 1px solid #d1d5db;
      background: #ffffff;
    }

    #bot-header button {
      padding: 6px 10px;
      font-size: 14px;
      background: #e5e7eb;
      color: #1f2937;
    }

    #bot-header button:hover {
      background: #d1d5db;
    }

    .form-section {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    label {
      font-weight: 600;
      color: #1f2937;
      font-size: 14px;
    }

    select,
    textarea {
      width: 100%;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      padding: 10px 12px;
      font-size: 14px;
      background: #ffffff;
      color: inherit;
    }

    textarea {
      resize: vertical;
      min-height: 160px;
      line-height: 1.5;
    }

    #media-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    #media-empty {
      border: 1px dashed #cbd5f5;
      border-radius: 10px;
      padding: 16px;
      text-align: center;
      color: #6b7280;
      font-size: 14px;
      background: #f8fafc;
    }

    .media-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      padding: 10px 12px;
      border: 1px solid #e5e5f7;
      border-radius: 12px;
      background: #f5f5ff;
    }

    .media-row select.media-type {
      width: 140px;
    }

    .media-row input.media-url {
      flex: 1 1 220px;
      min-width: 180px;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
    }

    .media-file-btn {
      background: #eef2ff;
      border: 1px solid #c7d2fe;
      padding: 10px 14px;
      border-radius: 10px;
      cursor: pointer;
      white-space: nowrap;
      font-size: 14px;
      color: #312e81;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 150px;
    }

    .media-file-btn:hover {
      background: #e0e7ff;
    }

    .dropzone {
      border: 1px dashed #c7d2fe;
      border-radius: 10px;
      padding: 12px;
      color: #4b5563;
      text-align: center;
      margin-top: 4px;
      font-size: 13px;
      transition: all 0.2s ease;
      width: 100%;
      flex-basis: 100%;
      background: #f8fafc;
    }

    .dropzone.dragover {
      background: #eef2ff;
      border-color: #6366f1;
      color: #1f2937;
    }

    .btn-secondary {
      background: #e5e7eb;
      color: #1f2937;
      padding: 8px 12px;
    }

    .btn-secondary:hover {
      background: #d1d5db;
    }

    .actions {
      display: flex;
      justify-content: flex-end;
    }

    #save-start {
      padding: 12px 20px;
      font-size: 15px;
    }

    dialog {
      border: none;
      border-radius: 12px;
      padding: 0;
      max-width: 420px;
      width: 100%;
      box-shadow: 0 25px 70px rgba(17, 24, 39, 0.35);
    }

    dialog::backdrop {
      background: rgba(15, 23, 42, 0.45);
    }

    .modal-form {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 22px 26px 26px;
      min-width: 320px;
    }

    .modal-form h3 {
      margin: 0 0 8px;
      font-size: 20px;
      color: #111827;
    }

    .modal-form label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-weight: 600;
      color: #1f2937;
      font-size: 14px;
    }

    .modal-form > button {
      align-self: flex-start;
    }

    .modal-form input[type='text'],
    .modal-form input[type='password'],
    .modal-form input[type='url'] {
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      font-size: 14px;
    }

    .modal-form menu {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin: 12px 0 0;
      padding: 0;
    }

    .modal-form menu button[value='cancel'] {
      background: #e5e7eb;
      color: #1f2937;
    }

    .modal-form menu button[value='cancel']:hover {
      background: #d1d5db;
    }

    #toast {
      position: fixed;
      top: 24px;
      right: 24px;
      background: #111827;
      color: #ffffff;
      padding: 12px 16px;
      border-radius: 10px;
      box-shadow: 0 15px 45px rgba(17, 24, 39, 0.4);
      font-size: 14px;
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      pointer-events: none;
      z-index: 1000;
    }

    #toast.show {
      opacity: 1;
      transform: translateY(0);
    }

    .status {
      border-radius: 10px;
      padding: 12px 16px;
      font-size: 14px;
      font-weight: 600;
    }

    .status.success {
      background: #dcfce7;
      color: #166534;
      border: 1px solid #bbf7d0;
    }

    .status.error {
      background: #fee2e2;
      color: #991b1b;
      border: 1px solid #fecaca;
    }

    .status.info {
      background: #e0f2fe;
      color: #075985;
      border: 1px solid #bae6fd;
    }

    @media (max-width: 720px) {
      body {
        padding: 16px;
      }

      .layout {
        padding: 20px;
      }

      header.top {
        align-items: stretch;
      }

      .card-header {
        flex-direction: column;
        align-items: stretch;
      }

      #bot-header {
        grid-template-columns: 1fr;
      }

      .token-input {
        flex-direction: column;
        align-items: stretch;
      }

      .token-input input,
      .token-input button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="layout">
    <header class="top">
      <div>
        <h1>🤖 Admin Wizard</h1>
        <p>Gerencie múltiplos bots do Telegram sem precisar de código.</p>
      </div>
      <div class="token-card">
        <label for="admin-token">Admin Token</label>
        <div class="token-input">
          <input id="admin-token" type="password" placeholder="Cole aqui o ADMIN_API_TOKEN" autocomplete="off">
          <button id="apply-token" type="button">Usar token</button>
        </div>
        <small style="color:#6b7280;">O token fica salvo apenas neste navegador.</small>
      </div>
    </header>

    <main class="card">
      <div class="card-header">
        <div>
          <h2>Templates /start</h2>
          <p>Escolha um bot para editar mensagem inicial, mídias e parse mode.</p>
        </div>
      </div>

      <div id="tabs">
        <div id="tabs-scroll"></div>
        <div id="bot-actions">
          <button id="btn-new-bot" type="button">+ Novo bot</button>
          <button id="btn-refresh-bots" type="button" title="Recarregar bots">↻</button>
        </div>
      </div>

      <div id="no-bots" class="hidden">
        Nenhum bot encontrado. Informe o token de admin e clique em ↻ para carregar os bots cadastrados.
      </div>

      <div id="pane" class="hidden">
        <div id="bot-header" class="card-section">
          <div>Bot ID: <code id="hdr-bot-id"></code></div>
          <div>Slug: <code id="hdr-bot-slug"></code></div>
          <div>
            <span>Token:</span>
            <input id="hdr-bot-token" type="password" readonly class="mono" value="">
            <button id="reveal-token" type="button" title="Mostrar token">👁</button>
          </div>
          <div>
            <span>Webhook:</span>
            <code id="hdr-webhook" class="mono"></code>
            <button id="copy-webhook" type="button">Copiar</button>
          </div>
        </div>

        <div class="form-section">
          <label for="parse-mode">Parse Mode</label>
          <select id="parse-mode">
            <option value="Markdown">Markdown</option>
            <option value="HTML">HTML</option>
          </select>
        </div>

        <div class="form-section">
          <label for="start-text">Mensagem inicial (/start)</label>
          <textarea id="start-text" placeholder="👋 Bem-vindo!"></textarea>
        </div>

        <div class="form-section">
          <div style="display:flex; justify-content: space-between; align-items: center; gap: 12px; flex-wrap: wrap;">
            <label style="margin:0;">Mídias (foto, vídeo ou áudio)</label>
            <button id="add-media" type="button" class="btn-secondary">➕ Adicionar mídia</button>
          </div>
          <div id="media-empty">Nenhuma mídia adicionada.</div>
          <div id="media-list"></div>
        </div>

        <div class="actions">
          <button id="save-start" type="button">Salvar Template /start</button>
        </div>

        <div id="status" class="status hidden"></div>
      </div>
    </main>
  </div>

  <dialog id="new-bot-modal">
    <form method="dialog" id="new-bot-form" class="modal-form">
      <h3>Novo bot</h3>
      <label>Slug*
        <input id="nb-slug" required pattern="^[a-z0-9]+(?:-[a-z0-9]+)*$" />
      </label>
      <label>Token do Telegram*
        <input id="nb-token" required type="password" autocomplete="off" />
      </label>
      <button type="button" id="nb-test-token">Testar token</button>
      <label>Nome/Título
        <input id="nb-title" />
      </label>
      <label>Secret webhook
        <input id="nb-secret" placeholder="(opcional)" />
      </label>
      <label><input type="checkbox" id="nb-sethook" checked /> Setar webhook automaticamente</label>
      <label><input type="checkbox" id="nb-empty" checked /> Criar template /start vazio</label>
      <menu>
        <button value="cancel">Cancelar</button>
        <button id="nb-create" value="default">Criar</button>
      </menu>
    </form>
  </dialog>

  <div id="toast" role="status" aria-live="polite"></div>

  <script>
    (() => {
      const tokenInput = document.getElementById('admin-token');
      const applyTokenBtn = document.getElementById('apply-token');
      const refreshBtn = document.getElementById('btn-refresh-bots');
      const newBotBtn = document.getElementById('btn-new-bot');
      const newBotModal = document.getElementById('new-bot-modal');
      const newBotForm = document.getElementById('new-bot-form');
      const paneEl = document.getElementById('pane');
      const noBotsEl = document.getElementById('no-bots');
      const tabsScroll = document.getElementById('tabs-scroll');
      const toastEl = document.getElementById('toast');
      const nbSlugInput = document.getElementById('nb-slug');
      const nbTokenInput = document.getElementById('nb-token');
      const nbTitleInput = document.getElementById('nb-title');
      const nbSecretInput = document.getElementById('nb-secret');
      const nbSetHookInput = document.getElementById('nb-sethook');
      const nbEmptyInput = document.getElementById('nb-empty');
      const nbTestTokenBtn = document.getElementById('nb-test-token');
      const nbCreateBtn = document.getElementById('nb-create');

      let ADMIN_TOKEN = localStorage.getItem('admin_token') || '';
      if (ADMIN_TOKEN) {
        tokenInput.value = ADMIN_TOKEN;
      }

      const state = {
        bots: [],
        currentBotId: null,
        dirty: new Set(),
        cache: new Map(),
      };

      let toastTimer = null;

      function getAdminToken() {
        return (ADMIN_TOKEN || '').trim();
      }

      function showToast(message) {
        if (!message) return;
        if (!toastEl) {
          alert(message);
          return;
        }
        toastEl.textContent = message;
        toastEl.classList.add('show');
        if (toastTimer) {
          clearTimeout(toastTimer);
        }
        toastTimer = setTimeout(() => {
          toastEl.classList.remove('show');
        }, 3000);
      }

      async function fetchJSON(url, opts = {}) {
        const headers = new Headers(opts.headers || {});
        const token = getAdminToken();
        if (!token) {
          throw new Error('Informe o token de admin para continuar.');
        }
        if (!headers.has('Authorization')) {
          headers.set('Authorization', `Bearer ${token}`);
        }
        const response = await fetch(url, { ...opts, headers });
        const text = await response.text();
        let data = null;
        if (text) {
          try {
            data = JSON.parse(text);
          } catch (err) {
            data = text;
          }
        }
        if (!response.ok) {
          const message = typeof data === 'object' && data !== null && 'error' in data
            ? data.error
            : data || response.statusText || 'Erro desconhecido';
          throw new Error(typeof message === 'string' ? message : 'Erro ao carregar dados');
        }
        return data;
      }

      function updateNoBotsVisibility() {
        const hasBots = state.bots.length > 0;
        if (!hasBots) {
          state.currentBotId = null;
        }
        noBotsEl.classList.toggle('hidden', hasBots);
        paneEl.classList.toggle('hidden', !hasBots || !state.currentBotId);
      }

      function deepClone(value) {
        return value == null ? value : JSON.parse(JSON.stringify(value));
      }

      function getBotIdFromHash() {
        const match = new URL(window.location.href).hash.match(/bot=([a-f0-9-]+)/i);
        return match ? match[1] : null;
      }

      async function loadBots({ preserveSelection = true, selectBotId = null } = {}) {
        try {
          const bots = await fetchJSON('/admin/bots');
          const previousId = preserveSelection ? state.currentBotId : null;
          state.bots = Array.isArray(bots) ? bots : [];

          const ids = new Set(state.bots.map((b) => b.id));
          Array.from(state.cache.keys()).forEach((key) => {
            if (!ids.has(key)) {
              state.cache.delete(key);
            }
          });
          Array.from(state.dirty).forEach((key) => {
            if (!ids.has(key)) {
              state.dirty.delete(key);
            }
          });

          let targetId = null;
          if (typeof selectBotId === 'string' && ids.has(selectBotId)) {
            targetId = selectBotId;
          }
          if (!targetId) {
            const hashId = getBotIdFromHash();
            if (hashId && ids.has(hashId)) {
              targetId = hashId;
            }
          }
          if (!targetId && previousId && ids.has(previousId)) {
            targetId = previousId;
          }
          if (!targetId && state.bots[0]) {
            targetId = state.bots[0].id;
          }

          renderTabs();
          updateNoBotsVisibility();

          if (targetId) {
            await selectBot(targetId);
          }
        } catch (err) {
          alert(err instanceof Error ? err.message : 'Erro ao carregar bots.');
          state.bots = [];
          renderTabs();
          updateNoBotsVisibility();
        }
      }

      function renderTabs() {
        tabsScroll.innerHTML = '';
        state.bots.forEach((bot) => {
          const tab = document.createElement('div');
          tab.className = 'tab' + (bot.id === state.currentBotId ? ' active' : '');
          tab.dataset.id = bot.id;
          const label = bot.slug || bot.name || bot.id.slice(0, 8);
          tab.textContent = label;
          if (state.dirty.has(bot.id)) {
            const badge = document.createElement('span');
            badge.className = 'dirty';
            badge.textContent = '*';
            tab.appendChild(badge);
          }
          tab.onclick = () => selectBot(bot.id);
          tabsScroll.appendChild(tab);
        });
      }

      async function selectBot(botId) {
        if (!state.bots.find((bot) => bot.id === botId)) {
          return;
        }
        if (state.currentBotId === botId) {
          history.replaceState(null, '', `#bot=${botId}`);
          updateNoBotsVisibility();
          return;
        }

        if (state.currentBotId && state.dirty.has(state.currentBotId)) {
          state.cache.set(state.currentBotId, pane.read());
        }

        state.currentBotId = botId;
        history.replaceState(null, '', `#bot=${botId}`);
        renderTabs();
        updateNoBotsVisibility();
        await loadBotPane(botId);
      }

      async function loadBotPane(botId) {
        try {
          let data = state.cache.get(botId);
          if (!data) {
            const fresh = await fetchJSON(`/admin/bots/${botId}/templates/start`);
            data = normalizeTemplate(fresh);
            state.cache.set(botId, deepClone(data));
          }
          const keepDirty = state.dirty.has(botId);
          pane.fill(botId, normalizeTemplate(data), { keepDirty });
          paneEl.classList.remove('hidden');
        } catch (err) {
          alert(err instanceof Error ? err.message : 'Erro ao carregar template.');
        }
      }

      function normalizeTemplate(raw) {
        const fallback = { parse_mode: 'Markdown', text: '', medias: [] };
        if (!raw || typeof raw !== 'object') {
          return fallback;
        }
        const parseMode = typeof raw.parse_mode === 'string' ? raw.parse_mode : fallback.parse_mode;
        const text = typeof raw.text === 'string' ? raw.text : fallback.text;
        const list = Array.isArray(raw.medias)
          ? raw.medias
          : Array.isArray(raw.media)
          ? raw.media.map((item) => ({ type: item.type, url: item.media }))
          : [];
        const medias = list
          .filter((item) => item && typeof item === 'object')
          .map((item) => ({
            type: item.type === 'video' || item.type === 'audio' ? item.type : 'photo',
            url: typeof item.url === 'string' ? item.url : typeof item.media === 'string' ? item.media : '',
          }));
        return { parse_mode: parseMode, text, medias };
      }

      const pane = (() => {
        const parseSel = document.getElementById('parse-mode');
        const textArea = document.getElementById('start-text');
        const mediaList = document.getElementById('media-list');
        const mediaEmpty = document.getElementById('media-empty');
        const addMediaBtn = document.getElementById('add-media');
        const saveBtn = document.getElementById('save-start');
        const statusEl = document.getElementById('status');
        const revealTokenBtn = document.getElementById('reveal-token');
        const copyWebhookBtn = document.getElementById('copy-webhook');
        const tokenField = document.getElementById('hdr-bot-token');

        function clearStatus() {
          statusEl.textContent = '';
          statusEl.className = 'status hidden';
        }

        function showStatus(type, message) {
          statusEl.textContent = message;
          statusEl.className = `status ${type}`;
        }

        function updateMediaEmptyState() {
          const hasRows = mediaList.querySelector('.media-row');
          mediaEmpty.classList.toggle('hidden', Boolean(hasRows));
        }

        function serializeRow(row) {
          const typeSel = row.querySelector('.media-type');
          const urlInput = row.querySelector('.media-url');
          return {
            type: (typeSel?.value || 'photo'),
            url: (urlInput?.value || '').trim(),
          };
        }

        function notifyChange() {
          if (!state.currentBotId) return;
          clearStatus();
          state.dirty.add(state.currentBotId);
          state.cache.set(state.currentBotId, read());
          renderTabs();
        }

        function attachUpload(row) {
          const removeBtn = row.querySelector('.media-del');
          const fileInput = row.querySelector('.media-file');
          const urlInput = row.querySelector('.media-url');
          const typeSelect = row.querySelector('.media-type');
          const dropzone = row.querySelector('.dropzone');

          if (removeBtn) {
            removeBtn.addEventListener('click', () => {
              row.remove();
              updateMediaEmptyState();
              notifyChange();
            });
          }

          if (urlInput) {
            urlInput.addEventListener('input', () => notifyChange());
          }

          if (typeSelect) {
            typeSelect.addEventListener('change', () => notifyChange());
          }

          async function uploadFile(file) {
            if (!file) return;
            if (!/^(image|video|audio)\//.test(file.type || '')) {
              alert('Tipo de arquivo não suportado. Selecione imagem, vídeo ou áudio.');
              return;
            }
            if (file.size > 20 * 1024 * 1024) {
              alert('Arquivo maior que 20MB. Selecione um arquivo menor.');
              return;
            }

            const formData = new FormData();
            formData.append('file', file);

            const buttonLabel = row.querySelector('.media-file-btn span');
            const originalLabel = buttonLabel ? buttonLabel.textContent : '';
            if (buttonLabel) {
              buttonLabel.textContent = 'Enviando…';
            }

            try {
              const headers = new Headers();
              const token = getAdminToken();
              if (token) {
                headers.set('Authorization', `Bearer ${token}`);
              }
              const response = await fetch('/api/admin/upload', {
                method: 'POST',
                body: formData,
                headers,
              });
              const data = await response.json().catch(() => ({}));
              if (!response.ok || !data?.ok || !data?.url) {
                const reason = data?.error || response.statusText || 'Falha no upload.';
                alert(`Erro no upload: ${reason}`);
                return;
              }
              if (urlInput) {
                urlInput.value = data.url;
              }
              notifyChange();
            } catch (error) {
              console.error(error);
              alert('Erro ao enviar arquivo.');
            } finally {
              if (buttonLabel) {
                buttonLabel.textContent = originalLabel || 'Enviar arquivo…';
              }
              if (fileInput) {
                fileInput.value = '';
              }
            }
          }

          if (fileInput) {
            fileInput.addEventListener('change', (event) => {
              const file = event?.target?.files?.[0];
              void uploadFile(file);
            });
          }

          if (dropzone) {
            dropzone.addEventListener('dragover', (event) => {
              event.preventDefault();
              dropzone.classList.add('dragover');
            });
            dropzone.addEventListener('dragleave', () => {
              dropzone.classList.remove('dragover');
            });
            dropzone.addEventListener('drop', (event) => {
              event.preventDefault();
              dropzone.classList.remove('dragover');
              const file = event?.dataTransfer?.files?.[0];
              void uploadFile(file);
            });
          }
        }

        function addMediaRow(initial) {
          const row = document.createElement('div');
          row.className = 'media-row';
          row.innerHTML = `
            <select class="media-type">
              <option value="photo">Foto</option>
              <option value="video">Vídeo</option>
              <option value="audio">Áudio</option>
            </select>
            <input type="url" class="media-url" placeholder="https://...">
            <label class="media-file-btn">
              <input type="file" class="media-file" accept="image/*,video/*,audio/*" hidden>
              <span>Enviar arquivo…</span>
            </label>
            <button type="button" class="btn-secondary media-del" title="Remover">🗑️</button>
            <div class="dropzone">Arraste e solte aqui ou clique em “Enviar arquivo…”</div>
          `;

          mediaList.appendChild(row);
          if (initial && typeof initial === 'object') {
            const typeSel = row.querySelector('.media-type');
            const urlInput = row.querySelector('.media-url');
            if (typeSel && initial.type) {
              typeSel.value = initial.type;
            }
            if (urlInput && initial.url) {
              urlInput.value = initial.url;
            }
          }

          attachUpload(row);
          updateMediaEmptyState();
          return row;
        }

        addMediaBtn.addEventListener('click', () => {
          addMediaRow();
          notifyChange();
        });

        parseSel.addEventListener('change', () => notifyChange());
        textArea.addEventListener('input', () => notifyChange());

        revealTokenBtn.addEventListener('click', () => {
          if (!tokenField.value) return;
          const isPassword = tokenField.type === 'password';
          tokenField.type = isPassword ? 'text' : 'password';
          revealTokenBtn.textContent = isPassword ? '🙈' : '👁';
        });

        copyWebhookBtn.addEventListener('click', async () => {
          const webhook = document.getElementById('hdr-webhook').textContent || '';
          if (!webhook || webhook === '—') {
            return;
          }
          try {
            await navigator.clipboard.writeText(webhook);
            showStatus('info', 'Webhook copiado para a área de transferência.');
            setTimeout(clearStatus, 2500);
          } catch (err) {
            console.warn(err);
            window.prompt('Copie o webhook manualmente:', webhook);
          }
        });

        saveBtn.addEventListener('click', async () => {
          if (!state.currentBotId) return;
          try {
            showStatus('info', 'Salvando…');
            const botId = state.currentBotId;
            const payload = read();
            const body = {
              parse_mode: payload.parse_mode,
              text: payload.text,
              media: payload.medias.map((item) => ({ type: item.type, media: item.url })),
            };
            await fetchJSON(`/admin/bots/${botId}/templates/start`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(body),
            });
            state.cache.set(botId, deepClone(payload));
            state.dirty.delete(botId);
            renderTabs();
            showStatus('success', 'Template /start salvo com sucesso!');
            setTimeout(clearStatus, 3500);
          } catch (err) {
            showStatus('error', err instanceof Error ? err.message : 'Erro ao salvar template.');
          }
        });

        function fill(botId, data, options = {}) {
          const normalized = normalizeTemplate(data);
          clearStatus();
          parseSel.value = normalized.parse_mode || 'Markdown';
          textArea.value = normalized.text || '';

          mediaList.innerHTML = '';
          (normalized.medias || []).forEach((item) => addMediaRow(item));
          updateMediaEmptyState();

          fillBotHeader(botId);

          if (!options.keepDirty) {
            state.dirty.delete(botId);
          }
          renderTabs();
        }

        function read() {
          const medias = Array.from(mediaList.querySelectorAll('.media-row'))
            .map((row) => serializeRow(row))
            .filter((item) => item.url);
          return {
            parse_mode: parseSel.value || 'Markdown',
            text: textArea.value || '',
            medias,
          };
        }

        return { fill, read, showStatus, clearStatus };
      })();

      function fillBotHeader(botId) {
        const bot = state.bots.find((b) => b.id === botId);
        if (!bot) return;
        const idEl = document.getElementById('hdr-bot-id');
        const slugEl = document.getElementById('hdr-bot-slug');
        const tokenEl = document.getElementById('hdr-bot-token');
        const webhookEl = document.getElementById('hdr-webhook');
        const copyBtn = document.getElementById('copy-webhook');
        const revealBtn = document.getElementById('reveal-token');

        idEl.textContent = bot.id;
        slugEl.textContent = bot.slug || '(sem slug)';
        tokenEl.type = 'password';
        revealBtn.textContent = '👁';
        if (bot.token) {
          tokenEl.value = bot.token;
        } else {
          tokenEl.value = '*****';
        }

        const origin = window.location.origin.replace(/\/$/, '');
        if (bot.slug) {
          webhookEl.textContent = `${origin}/tg/${bot.slug}/webhook`;
          copyBtn.disabled = false;
        } else {
          webhookEl.textContent = '—';
          copyBtn.disabled = true;
        }
      }

      if (newBotBtn && newBotModal && typeof newBotModal.showModal === 'function') {
        newBotBtn.addEventListener('click', () => {
          if (newBotForm) {
            newBotForm.reset();
          }
          if (nbSetHookInput) {
            nbSetHookInput.checked = true;
          }
          if (nbEmptyInput) {
            nbEmptyInput.checked = true;
          }
          if (nbSecretInput) {
            nbSecretInput.value = '';
          }
          if (nbTokenInput) {
            nbTokenInput.value = '';
          }
          newBotModal.showModal();
          if (nbSlugInput) {
            nbSlugInput.focus();
          }
        });
      } else if (newBotBtn) {
        newBotBtn.addEventListener('click', () => {
          alert('Seu navegador não suporta a abertura do modal de novo bot.');
        });
      }

      nbTestTokenBtn?.addEventListener('click', async () => {
        const token = (nbTokenInput?.value || '').trim();
        if (!token) {
          alert('Informe o token');
          return;
        }
        try {
          const response = await fetch(`https://api.telegram.org/bot${token}/getMe`);
          const data = await response.json().catch(() => null);
          if (data?.ok) {
            const username = data?.result?.username ? `@${data.result.username}` : null;
            alert(username ? `Token OK: ${username}` : 'Token OK');
          } else {
            alert('Token inválido');
          }
        } catch (error) {
          console.warn(error);
          alert('Token inválido');
        }
      });

      nbCreateBtn?.addEventListener('click', async (event) => {
        event.preventDefault();

        const payload = {
          slug: (nbSlugInput?.value || '').trim(),
          token: (nbTokenInput?.value || '').trim(),
          title: (nbTitleInput?.value || '').trim(),
          secret: (nbSecretInput?.value || '').trim(),
          setWebhook: nbSetHookInput ? Boolean(nbSetHookInput.checked) : true,
          createEmptyTemplate: nbEmptyInput ? Boolean(nbEmptyInput.checked) : true,
        };

        if (!payload.slug || !/^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(payload.slug)) {
          alert('Slug inválido');
          return;
        }
        if (!payload.token) {
          alert('Informe o token');
          return;
        }

        const adminToken = getAdminToken();
        if (!adminToken) {
          alert('Informe o token de admin para continuar.');
          return;
        }

        const body = {
          slug: payload.slug,
          token: payload.token,
          title: payload.title || null,
          secret: payload.secret || null,
          setWebhook: payload.setWebhook,
          createEmptyTemplate: payload.createEmptyTemplate,
        };

        try {
          if (nbCreateBtn) {
            nbCreateBtn.disabled = true;
          }
          const res = await fetch('/admin/bots', {
            method: 'POST',
            headers: {
              Authorization: `Bearer ${adminToken}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(body),
          });

          if (!res.ok) {
            const err = await res.json().catch(() => ({}));
            if (res.status === 409) {
              alert('Esse slug já está em uso.');
            } else if (err?.error === 'telegram_token_invalid') {
              alert('Token do Telegram inválido.');
            } else if (err?.error === 'failed_to_set_webhook') {
              alert('Não foi possível configurar o webhook automaticamente.');
            } else {
              alert(`Erro ao criar: ${res.status} ${err?.error || ''}`.trim());
            }
            return;
          }

          const bot = await res.json();
          const newBotId = bot && typeof bot.id === 'string' ? bot.id : null;
          newBotModal?.close();
          if (newBotForm) {
            newBotForm.reset();
          }
          await loadBots({ preserveSelection: false, selectBotId: newBotId });
          showToast('Bot criado');
        } catch (error) {
          console.error(error);
          alert('Falha ao criar bot');
        } finally {
          if (nbCreateBtn) {
            nbCreateBtn.disabled = false;
          }
        }
      });

      applyTokenBtn.addEventListener('click', () => {
        ADMIN_TOKEN = tokenInput.value.trim();
        if (!ADMIN_TOKEN) {
          alert('Informe o token de admin para continuar.');
          localStorage.removeItem('admin_token');
          state.bots = [];
          state.cache.clear();
          state.dirty.clear();
          state.currentBotId = null;
          renderTabs();
          updateNoBotsVisibility();
          return;
        }
        localStorage.setItem('admin_token', ADMIN_TOKEN);
        loadBots({ preserveSelection: false });
      });

      tokenInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          applyTokenBtn.click();
        }
      });

      refreshBtn?.addEventListener('click', () => {
        if (!getAdminToken()) {
          alert('Informe o token de admin para continuar.');
          return;
        }
        loadBots();
      });

      window.addEventListener('hashchange', () => {
        const targetId = getBotIdFromHash();
        if (targetId && targetId !== state.currentBotId) {
          void selectBot(targetId);
        }
      });

      window.addEventListener('beforeunload', (event) => {
        if (state.dirty.size) {
          event.preventDefault();
          event.returnValue = '';
        }
      });

      if (getAdminToken()) {
        loadBots();
      } else {
        updateNoBotsVisibility();
      }
    })();
  </script>
</body>
</html>
